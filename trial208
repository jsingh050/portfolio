import cv2
import numpy as np

# Initialize video writers- this wouldn't work :(
fourcc = cv2.VideoWriter_fourcc(*'XVID')
output_original = cv2.VideoWriter('output_original.avi', fourcc, 20.0, (640, 480))
output_processed = cv2.VideoWriter('output_processed.avi', fourcc, 20.0, (640, 480), isColor=False)

# Initialize webcam
cap = cv2.VideoCapture(0)

# Check if the webcam is opened correctly
if not cap.isOpened():
    print("Error: Could not open webcam")
    exit()

# Define thresholds
PIX_ON_THRESH = 30
PIX_OFF_THRESH = -240

# Read the first frame and convert to grayscale
ret, first_frame = cap.read()
if not ret:
    print("Error: Could not read frame")
    exit()
first_gray_frame = cv2.cvtColor(first_frame, cv2.COLOR_BGR2GRAY).astype(np.int16)

while True:
    # Read the current frame
    ret, current_frame = cap.read()
    if not ret:
        print("Error: Could not read frame")
        break

    # Convert the current frame to 8-bit grayscale
    gray_frame = cv2.cvtColor(current_frame, cv2.COLOR_BGR2GRAY).astype(np.int16)

    # Compute the difference between the current and previous frames
    frame_diff = gray_frame - first_gray_frame

    # Apply a windowed threshold function
    events = np.zeros_like(frame_diff, dtype=np.int16)
    events[frame_diff > PIX_ON_THRESH] = 1
    events[frame_diff < PIX_OFF_THRESH] = -1

    # Convert events back to uint8 for displaying
    events_display = np.uint8((events + 1) * 127)

    # Display the resulting frame real-time
    cv2.imshow('Neuromorphic Vision', events_display)

    # Write original and processed frames to video files
    output_original.write(current_frame)
    output_processed.write(events_display)

    # Update the previous frame for the next iteration
    first_gray_frame = gray_frame.copy()

    # Break the loop if 'q' key is pressed
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release resources
cap.release()
output_original.release()
output_processed.release()
cv2.destroyAllWindows()
